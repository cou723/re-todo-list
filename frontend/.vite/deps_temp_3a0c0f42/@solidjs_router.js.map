{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@solidjs+router@0.8.2_solid-js@1.7.6/node_modules/@solidjs/router/dist/index.js"],
  "sourcesContent": ["import { isServer, delegateEvents, createComponent as createComponent$1, spread, mergeProps as mergeProps$1, template } from 'solid-js/web';\nimport { createSignal, onCleanup, getOwner, runWithOwner, createMemo, createContext, useContext, untrack, createRenderEffect, createComponent, on, startTransition, resetErrorBoundaries, children, createRoot, Show, mergeProps, splitProps } from 'solid-js';\n\nfunction bindEvent(target, type, handler) {\n  target.addEventListener(type, handler);\n  return () => target.removeEventListener(type, handler);\n}\nfunction intercept([value, setValue], get, set) {\n  return [get ? () => get(value()) : value, set ? v => setValue(set(v)) : setValue];\n}\nfunction querySelector(selector) {\n  // Guard against selector being an invalid CSS selector\n  try {\n    return document.querySelector(selector);\n  } catch (e) {\n    return null;\n  }\n}\nfunction scrollToHash(hash, fallbackTop) {\n  const el = querySelector(`#${hash}`);\n  if (el) {\n    el.scrollIntoView();\n  } else if (fallbackTop) {\n    window.scrollTo(0, 0);\n  }\n}\nfunction createMemoryHistory() {\n  const entries = [\"/\"];\n  let index = 0;\n  const listeners = [];\n  const go = n => {\n    // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\n    index = Math.max(0, Math.min(index + n, entries.length - 1));\n    const value = entries[index];\n    listeners.forEach(listener => listener(value));\n  };\n  return {\n    get: () => entries[index],\n    set: ({\n      value,\n      scroll,\n      replace\n    }) => {\n      if (replace) {\n        entries[index] = value;\n      } else {\n        entries.splice(index + 1, entries.length - index, value);\n        index++;\n      }\n      if (scroll) {\n        scrollToHash(value.split(\"#\")[1] || \"\", true);\n      }\n    },\n    back: () => {\n      go(-1);\n    },\n    forward: () => {\n      go(1);\n    },\n    go,\n    listen: listener => {\n      listeners.push(listener);\n      return () => {\n        const index = listeners.indexOf(listener);\n        listeners.splice(index, 1);\n      };\n    }\n  };\n}\nfunction createIntegration(get, set, init, utils) {\n  let ignore = false;\n  const wrap = value => typeof value === \"string\" ? {\n    value\n  } : value;\n  const signal = intercept(createSignal(wrap(get()), {\n    equals: (a, b) => a.value === b.value\n  }), undefined, next => {\n    !ignore && set(next);\n    return next;\n  });\n  init && onCleanup(init((value = get()) => {\n    ignore = true;\n    signal[1](wrap(value));\n    ignore = false;\n  }));\n  return {\n    signal,\n    utils\n  };\n}\nfunction normalizeIntegration(integration) {\n  if (!integration) {\n    return {\n      signal: createSignal({\n        value: \"\"\n      })\n    };\n  } else if (Array.isArray(integration)) {\n    return {\n      signal: integration\n    };\n  }\n  return integration;\n}\nfunction staticIntegration(obj) {\n  return {\n    signal: [() => obj, next => Object.assign(obj, next)]\n  };\n}\nfunction pathIntegration() {\n  return createIntegration(() => ({\n    value: window.location.pathname + window.location.search + window.location.hash,\n    state: history.state\n  }), ({\n    value,\n    replace,\n    scroll,\n    state\n  }) => {\n    if (replace) {\n      window.history.replaceState(state, \"\", value);\n    } else {\n      window.history.pushState(state, \"\", value);\n    }\n    scrollToHash(window.location.hash.slice(1), scroll);\n  }, notify => bindEvent(window, \"popstate\", () => notify()), {\n    go: delta => window.history.go(delta)\n  });\n}\nfunction hashIntegration() {\n  return createIntegration(() => window.location.hash.slice(1), ({\n    value,\n    replace,\n    scroll,\n    state\n  }) => {\n    if (replace) {\n      window.history.replaceState(state, \"\", \"#\" + value);\n    } else {\n      window.location.hash = value;\n    }\n    const hashIndex = value.indexOf(\"#\");\n    const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\n    scrollToHash(hash, scroll);\n  }, notify => bindEvent(window, \"hashchange\", () => notify()), {\n    go: delta => window.history.go(delta),\n    renderPath: path => `#${path}`,\n    parsePath: str => {\n      const to = str.replace(/^.*?#/, \"\");\n      // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\n      // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\n      // to the current path so we can handle these in-page anchors correctly.\n      if (!to.startsWith(\"/\")) {\n        const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\n        return `${path}#${to}`;\n      }\n      return to;\n    }\n  });\n}\nfunction memoryIntegration() {\n  const memoryHistory = createMemoryHistory();\n  return createIntegration(memoryHistory.get, memoryHistory.set, memoryHistory.listen, {\n    go: memoryHistory.go\n  });\n}\n\nfunction createBeforeLeave() {\n  let listeners = new Set();\n  function subscribe(listener) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n  let ignore = false;\n  function confirm(to, options) {\n    if (ignore) return !(ignore = false);\n    const e = {\n      to,\n      options,\n      defaultPrevented: false,\n      preventDefault: () => e.defaultPrevented = true\n    };\n    for (const l of listeners) l.listener({\n      ...e,\n      from: l.location,\n      retry: force => {\n        force && (ignore = true);\n        l.navigate(to, options);\n      }\n    });\n    return !e.defaultPrevented;\n  }\n  return {\n    subscribe,\n    confirm\n  };\n}\n\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nfunction normalizePath(path, omitSlash = false) {\n  const s = path.replace(trimPathRegex, \"$1\");\n  return s ? omitSlash || /^[?#]/.test(s) ? s : \"/\" + s : \"\";\n}\nfunction resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalizePath(base);\n  const fromPath = from && normalizePath(from);\n  let result = \"\";\n  if (!fromPath || path.startsWith(\"/\")) {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return (result || \"/\") + normalizePath(path, !result);\n}\nfunction invariant(value, message) {\n  if (value == null) {\n    throw new Error(message);\n  }\n  return value;\n}\nfunction joinPaths(from, to) {\n  return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nfunction extractSearchParams(url) {\n  const params = {};\n  url.searchParams.forEach((value, key) => {\n    params[key] = value;\n  });\n  return params;\n}\nfunction createMatcher(path, partial, matchFilters) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  return location => {\n    const locSegments = location.split(\"/\").filter(Boolean);\n    const lenDiff = locSegments.length - len;\n    if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {\n      return null;\n    }\n    const match = {\n      path: len ? \"\" : \"/\",\n      params: {}\n    };\n    const matchFilter = s => matchFilters === undefined ? undefined : matchFilters[s];\n    for (let i = 0; i < len; i++) {\n      const segment = segments[i];\n      const locSegment = locSegments[i];\n      const dynamic = segment[0] === \":\";\n      const key = dynamic ? segment.slice(1) : segment;\n      if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n        match.params[key] = locSegment;\n      } else if (dynamic || !matchSegment(locSegment, segment)) {\n        return null;\n      }\n      match.path += `/${locSegment}`;\n    }\n    if (splat) {\n      const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n      if (matchSegment(remainder, matchFilter(splat))) {\n        match.params[splat] = remainder;\n      } else {\n        return null;\n      }\n    }\n    return match;\n  };\n}\nfunction matchSegment(input, filter) {\n  const isEqual = s => s.localeCompare(input, undefined, {\n    sensitivity: \"base\"\n  }) === 0;\n  if (filter === undefined) {\n    return true;\n  } else if (typeof filter === \"string\") {\n    return isEqual(filter);\n  } else if (typeof filter === \"function\") {\n    return filter(input);\n  } else if (Array.isArray(filter)) {\n    return filter.some(isEqual);\n  } else if (filter instanceof RegExp) {\n    return filter.test(input);\n  }\n  return false;\n}\nfunction scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nfunction createMemoObject(fn) {\n  const map = new Map();\n  const owner = getOwner();\n  return new Proxy({}, {\n    get(_, property) {\n      if (!map.has(property)) {\n        runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n      }\n      return map.get(property)();\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    },\n    ownKeys() {\n      return Reflect.ownKeys(fn());\n    }\n  });\n}\nfunction mergeSearchString(search, params) {\n  const merged = new URLSearchParams(search);\n  Object.entries(params).forEach(([key, value]) => {\n    if (value == null || value === \"\") {\n      merged.delete(key);\n    } else {\n      merged.set(key, String(value));\n    }\n  });\n  const s = merged.toString();\n  return s ? `?${s}` : \"\";\n}\nfunction expandOptionals(pattern) {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match) return [pattern];\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes = [prefix, prefix += match[1]];\n\n  // This section handles adjacent optional params. We don't actually want all permuations since\n  // that will lead to equivalent routes which have the same number of params. For example\n  // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n  // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n  // ensure predictability where earlier params have precidence.\n  while (match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix)) {\n    prefixes.push(prefix += match[1]);\n    suffix = suffix.slice(match[0].length);\n  }\n  return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n\nconst MAX_REDIRECTS = 100;\nconst RouterContextObj = createContext();\nconst RouteContextObj = createContext();\nconst useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\nlet TempRoute;\nconst useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nconst useResolvedPath = path => {\n  const route = useRoute();\n  return createMemo(() => route.resolvePath(path()));\n};\nconst useHref = to => {\n  const router = useRouter();\n  return createMemo(() => {\n    const to_ = to();\n    return to_ !== undefined ? router.renderPath(to_) : to_;\n  });\n};\nconst useNavigate = () => useRouter().navigatorFactory();\nconst useLocation = () => useRouter().location;\nconst useIsRouting = () => useRouter().isRouting;\nconst useMatch = (path, matchFilters) => {\n  const location = useLocation();\n  const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n  return createMemo(() => {\n    for (const matcher of matchers()) {\n      const match = matcher(location.pathname);\n      if (match) return match;\n    }\n  });\n};\nconst useParams = () => useRoute().params;\nconst useRouteData = () => useRoute().data;\nconst useSearchParams = () => {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const setSearchParams = (params, options) => {\n    const searchString = untrack(() => mergeSearchString(location.search, params));\n    navigate(location.pathname + searchString + location.hash, {\n      scroll: false,\n      resolve: false,\n      ...options\n    });\n  };\n  return [location.query, setSearchParams];\n};\nconst useBeforeLeave = listener => {\n  const s = useRouter().beforeLeave.subscribe({\n    listener,\n    location: useLocation(),\n    navigate: useNavigate()\n  });\n  onCleanup(s);\n};\nfunction createRoutes(routeDef, base = \"\", fallback) {\n  const {\n    component,\n    data,\n    children\n  } = routeDef;\n  const isLeaf = !children || Array.isArray(children) && !children.length;\n  const shared = {\n    key: routeDef,\n    element: component ? () => createComponent(component, {}) : () => {\n      const {\n        element\n      } = routeDef;\n      return element === undefined && fallback ? createComponent(fallback, {}) : element;\n    },\n    preload: routeDef.component ? component.preload : routeDef.preload,\n    data\n  };\n  return asArray(routeDef.path).reduce((acc, path) => {\n    for (const originalPath of expandOptionals(path)) {\n      const path = joinPaths(base, originalPath);\n      const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n      acc.push({\n        ...shared,\n        originalPath,\n        pattern,\n        matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n      });\n    }\n    return acc;\n  }, []);\n}\nfunction createBranch(routes, index = 0) {\n  return {\n    routes,\n    score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n    matcher(location) {\n      const matches = [];\n      for (let i = routes.length - 1; i >= 0; i--) {\n        const route = routes[i];\n        const match = route.matcher(location);\n        if (!match) {\n          return null;\n        }\n        matches.unshift({\n          ...match,\n          route\n        });\n      }\n      return matches;\n    }\n  };\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\n  const routeDefs = asArray(routeDef);\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\n      const routes = createRoutes(def, base, fallback);\n      for (const route of routes) {\n        stack.push(route);\n        const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n        if (def.children && !isEmptyArray) {\n          createBranches(def.children, route.pattern, fallback, stack, branches);\n        } else {\n          const branch = createBranch([...stack], branches.length);\n          branches.push(branch);\n        }\n        stack.pop();\n      }\n    }\n  }\n\n  // Stack will be empty on final return\n  return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nfunction getRouteMatches(branches, location) {\n  for (let i = 0, len = branches.length; i < len; i++) {\n    const match = branches[i].matcher(location);\n    if (match) {\n      return match;\n    }\n  }\n  return [];\n}\nfunction createLocation(path, state) {\n  const origin = new URL(\"http://sar\");\n  const url = createMemo(prev => {\n    const path_ = path();\n    try {\n      return new URL(path_, origin);\n    } catch (err) {\n      console.error(`Invalid path ${path_}`);\n      return prev;\n    }\n  }, origin, {\n    equals: (a, b) => a.href === b.href\n  });\n  const pathname = createMemo(() => url().pathname);\n  const search = createMemo(() => url().search, true);\n  const hash = createMemo(() => url().hash);\n  const key = createMemo(() => \"\");\n  return {\n    get pathname() {\n      return pathname();\n    },\n    get search() {\n      return search();\n    },\n    get hash() {\n      return hash();\n    },\n    get state() {\n      return state();\n    },\n    get key() {\n      return key();\n    },\n    query: createMemoObject(on(search, () => extractSearchParams(url())))\n  };\n}\nfunction createRouterContext(integration, base = \"\", data, out) {\n  const {\n    signal: [source, setSource],\n    utils = {}\n  } = normalizeIntegration(integration);\n  const parsePath = utils.parsePath || (p => p);\n  const renderPath = utils.renderPath || (p => p);\n  const beforeLeave = utils.beforeLeave || createBeforeLeave();\n  const basePath = resolvePath(\"\", base);\n  const output = isServer && out ? Object.assign(out, {\n    matches: [],\n    url: undefined\n  }) : undefined;\n  if (basePath === undefined) {\n    throw new Error(`${basePath} is not a valid base path`);\n  } else if (basePath && !source().value) {\n    setSource({\n      value: basePath,\n      replace: true,\n      scroll: false\n    });\n  }\n  const [isRouting, setIsRouting] = createSignal(false);\n  const start = async callback => {\n    setIsRouting(true);\n    try {\n      await startTransition(callback);\n    } finally {\n      setIsRouting(false);\n    }\n  };\n  const [reference, setReference] = createSignal(source().value);\n  const [state, setState] = createSignal(source().state);\n  const location = createLocation(reference, state);\n  const referrers = [];\n  const baseRoute = {\n    pattern: basePath,\n    params: {},\n    path: () => basePath,\n    outlet: () => null,\n    resolvePath(to) {\n      return resolvePath(basePath, to);\n    }\n  };\n  if (data) {\n    try {\n      TempRoute = baseRoute;\n      baseRoute.data = data({\n        data: undefined,\n        params: {},\n        location,\n        navigate: navigatorFactory(baseRoute)\n      });\n    } finally {\n      TempRoute = undefined;\n    }\n  }\n  function navigateFromRoute(route, to, options) {\n    // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n    untrack(() => {\n      if (typeof to === \"number\") {\n        if (!to) ; else if (utils.go) {\n          beforeLeave.confirm(to, options) && utils.go(to);\n        } else {\n          console.warn(\"Router integration does not support relative routing\");\n        }\n        return;\n      }\n      const {\n        replace,\n        resolve,\n        scroll,\n        state: nextState\n      } = {\n        replace: false,\n        resolve: true,\n        scroll: true,\n        ...options\n      };\n      const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n      if (resolvedTo === undefined) {\n        throw new Error(`Path '${to}' is not a routable path`);\n      } else if (referrers.length >= MAX_REDIRECTS) {\n        throw new Error(\"Too many redirects\");\n      }\n      const current = reference();\n      if (resolvedTo !== current || nextState !== state()) {\n        if (isServer) {\n          if (output) {\n            output.url = resolvedTo;\n          }\n          setSource({\n            value: resolvedTo,\n            replace,\n            scroll,\n            state: nextState\n          });\n        } else if (beforeLeave.confirm(resolvedTo, options)) {\n          const len = referrers.push({\n            value: current,\n            replace,\n            scroll,\n            state: state()\n          });\n          start(() => {\n            setReference(resolvedTo);\n            setState(nextState);\n            resetErrorBoundaries();\n          }).then(() => {\n            if (referrers.length === len) {\n              navigateEnd({\n                value: resolvedTo,\n                state: nextState\n              });\n            }\n          });\n        }\n      }\n    });\n  }\n  function navigatorFactory(route) {\n    // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n    route = route || useContext(RouteContextObj) || baseRoute;\n    return (to, options) => navigateFromRoute(route, to, options);\n  }\n  function navigateEnd(next) {\n    const first = referrers[0];\n    if (first) {\n      if (next.value !== first.value || next.state !== first.state) {\n        setSource({\n          ...next,\n          replace: first.replace,\n          scroll: first.scroll\n        });\n      }\n      referrers.length = 0;\n    }\n  }\n  createRenderEffect(() => {\n    const {\n      value,\n      state\n    } = source();\n    // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\n    untrack(() => {\n      if (value !== reference()) {\n        start(() => {\n          setReference(value);\n          setState(state);\n        });\n      }\n    });\n  });\n  if (!isServer) {\n    function handleAnchorClick(evt) {\n      if (evt.defaultPrevented || evt.button !== 0 || evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey) return;\n      const a = evt.composedPath().find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\n      if (!a || !a.hasAttribute(\"link\")) return;\n      const href = a.href;\n      if (a.target || !href && !a.hasAttribute(\"state\")) return;\n      const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n      if (a.hasAttribute(\"download\") || rel && rel.includes(\"external\")) return;\n      const url = new URL(href);\n      if (url.origin !== window.location.origin || basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())) return;\n      const to = parsePath(url.pathname + url.search + url.hash);\n      const state = a.getAttribute(\"state\");\n      evt.preventDefault();\n      navigateFromRoute(baseRoute, to, {\n        resolve: false,\n        replace: a.hasAttribute(\"replace\"),\n        scroll: !a.hasAttribute(\"noscroll\"),\n        state: state && JSON.parse(state)\n      });\n    }\n\n    // ensure delegated events run first\n    delegateEvents([\"click\"]);\n    document.addEventListener(\"click\", handleAnchorClick);\n    onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\n  }\n  return {\n    base: baseRoute,\n    out: output,\n    location,\n    isRouting,\n    renderPath,\n    parsePath,\n    navigatorFactory,\n    beforeLeave\n  };\n}\nfunction createRouteContext(router, parent, child, match, params) {\n  const {\n    base,\n    location,\n    navigatorFactory\n  } = router;\n  const {\n    pattern,\n    element: outlet,\n    preload,\n    data\n  } = match().route;\n  const path = createMemo(() => match().path);\n  preload && preload();\n  const route = {\n    parent,\n    pattern,\n    get child() {\n      return child();\n    },\n    path,\n    params,\n    data: parent.data,\n    outlet,\n    resolvePath(to) {\n      return resolvePath(base.path(), to, path());\n    }\n  };\n  if (data) {\n    try {\n      TempRoute = route;\n      route.data = data({\n        data: parent.data,\n        params,\n        location,\n        navigate: navigatorFactory(route)\n      });\n    } finally {\n      TempRoute = undefined;\n    }\n  }\n  return route;\n}\n\nconst _tmpl$ = /*#__PURE__*/template(`<a link></a>`, 2);\nconst Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return createComponent$1(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return createComponent$1(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => createComponent$1(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nconst useRoutes = (routes, base) => {\n  return () => createComponent$1(Routes, {\n    base: base,\n    children: routes\n  });\n};\nconst Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nconst Outlet = () => {\n  const route = useRoute();\n  return createComponent$1(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => createComponent$1(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nfunction A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n    spread(_el$, mergeProps$1(rest, {\n      get href() {\n        return href() || props.href;\n      },\n      get state() {\n        return JSON.stringify(props.state);\n      },\n      get classList() {\n        return {\n          ...(props.class && {\n            [props.class]: true\n          }),\n          [props.inactiveClass]: !isActive(),\n          [props.activeClass]: isActive(),\n          ...rest.classList\n        };\n      },\n      get [\"aria-current\"]() {\n        return isActive() ? \"page\" : undefined;\n      }\n    }), false, false);\n    return _el$;\n  })();\n}\nfunction Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}\n\nexport { A, A as Link, A as NavLink, Navigate, Outlet, Route, Router, Routes, mergeSearchString as _mergeSearchString, createBeforeLeave, createIntegration, createMemoryHistory, hashIntegration, memoryIntegration, normalizeIntegration, pathIntegration, staticIntegration, useBeforeLeave, useHref, useIsRouting, useLocation, useMatch, useNavigate, useParams, useResolvedPath, useRouteData, useRoutes, useSearchParams };\n"],
  "mappings": "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",
  "names": ["index", "path", "children", "state", "params"]
}
