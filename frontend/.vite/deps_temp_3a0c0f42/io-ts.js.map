{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/function.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/internal.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Apply.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Functor.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Applicative.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Chain.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/FromEither.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Separated.js", "../../node_modules/.pnpm/fp-ts@2.16.0/node_modules/fp-ts/es6/Either.js", "../../node_modules/.pnpm/io-ts@2.2.20_fp-ts@2.16.0/node_modules/io-ts/es6/index.js"],
  "sourcesContent": ["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n", "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n", "/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nimport { tuple } from './function';\nimport * as _ from './internal';\nexport function ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexport function apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexport function apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexport function apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexport function getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nexport function sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nexport function sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n", "/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n", "/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n    var f = getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n    var map = getFunctorComposition(F, G).map;\n    var _ap = ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return pipe(fgab, _ap(fga)); }\n    };\n}\n", "export function chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nexport function tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexport function bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n", "/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nimport * as _ from './internal';\nexport function fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nexport function fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nexport function fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return flow(f, from); };\n    };\n}\nexport function chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nexport function fromEitherK(F) {\n    return function (f) { return flow(f, F.fromEither); };\n}\nexport function chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nexport function chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nexport function filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nexport function tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = tap(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n", "/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function (left, right) { return ({ left: left, right: right }); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\nvar _bimap = function (fa, g, f) { return pipe(fa, bimap(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = function (f) {\n    return function (fa) {\n        return separated(left(fa), f(right(fa)));\n    };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var mapLeft = function (f) {\n    return function (fa) {\n        return separated(f(left(fa)), right(fa));\n    };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var bimap = function (f, g) {\n    return function (fa) {\n        return separated(f(left(fa)), g(right(fa)));\n    };\n};\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function (s) { return s.left; };\n/**\n * @since 2.10.0\n */\nexport var right = function (s) { return s.right; };\n", "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n", "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @since 1.0.0\n */\nimport { isLeft, left, right } from 'fp-ts/es6/Either';\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var failures = left;\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var failure = function (value, context, message) {\n    return failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var success = right;\n/**\n * @category Codec\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\".concat(this.name, \", \").concat(ab.name, \")\"); }\n        return new Type(name, ab.is, function (i, c) {\n            var e = _this.validate(i, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            return ab.validate(e.right, c);\n        }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /**\n     * a version of `validate` with a default context\n     * @since 1.0.0\n     */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\nexport { Type };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nexport var identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nexport function getFunctionName(f) {\n    return f.displayName || f.name || \"<function\".concat(f.length, \">\");\n}\n/**\n * @since 1.0.0\n */\nexport function getContextEntry(key, decoder) {\n    return { key: key, type: decoder };\n}\n/**\n * @since 1.0.0\n */\nexport function appendContext(c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n}\nfunction pushAll(xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getNameFromProps(props) {\n    return Object.keys(props)\n        .map(function (k) { return \"\".concat(k, \": \").concat(props[k].name); })\n        .join(', ');\n}\nfunction useIdentity(codecs) {\n    for (var i = 0; i < codecs.length; i++) {\n        if (codecs[i].encode !== identity) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getInterfaceTypeName(props) {\n    return \"{ \".concat(getNameFromProps(props), \" }\");\n}\nfunction getPartialTypeName(inner) {\n    return \"Partial<\".concat(inner, \">\");\n}\nfunction enumerableRecord(keys, domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \".concat(domain.name, \"]: \").concat(codomain.name, \" }\"); }\n    var len = keys.length;\n    return new DictionaryType(name, function (u) { return UnknownRecord.is(u) && keys.every(function (k) { return codomain.is(u[k]); }); }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = {};\n        var errors = [];\n        var changed = false;\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ok = o[k];\n            var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));\n            if (isLeft(codomainResult)) {\n                pushAll(errors, codomainResult.left);\n            }\n            else {\n                var vok = codomainResult.right;\n                changed = changed || vok !== ok;\n                a[k] = vok;\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success((changed || Object.keys(o).length !== len ? a : o));\n    }, codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[k] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n}\n/**\n * @internal\n */\nexport function getDomainKeys(domain) {\n    var _a;\n    if (isLiteralC(domain)) {\n        var literal_1 = domain.value;\n        if (string.is(literal_1)) {\n            return _a = {}, _a[literal_1] = null, _a;\n        }\n    }\n    else if (isKeyofC(domain)) {\n        return domain.keys;\n    }\n    else if (isUnionC(domain)) {\n        var keys = domain.types.map(function (type) { return getDomainKeys(type); });\n        return keys.some(undefinedType.is) ? undefined : Object.assign.apply(Object, __spreadArray([{}], keys, false));\n    }\n    return undefined;\n}\nfunction nonEnumerableRecord(domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \".concat(domain.name, \"]: \").concat(codomain.name, \" }\"); }\n    return new DictionaryType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });\n        }\n        return isAnyC(codomain) && Array.isArray(u);\n    }, function (u, c) {\n        if (UnknownRecord.is(u)) {\n            var a = {};\n            var errors = [];\n            var keys = Object.keys(u);\n            var len = keys.length;\n            var changed = false;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ok = u[k];\n                var domainResult = domain.validate(k, appendContext(c, k, domain, k));\n                if (isLeft(domainResult)) {\n                    pushAll(errors, domainResult.left);\n                }\n                else {\n                    var vk = domainResult.right;\n                    changed = changed || vk !== k;\n                    k = vk;\n                    var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));\n                    if (isLeft(codomainResult)) {\n                        pushAll(errors, codomainResult.left);\n                    }\n                    else {\n                        var vok = codomainResult.right;\n                        changed = changed || vok !== ok;\n                        a[k] = vok;\n                    }\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success((changed ? a : u));\n        }\n        if (isAnyC(codomain) && Array.isArray(u)) {\n            return success(u);\n        }\n        return failure(u, c);\n    }, domain.encode === identity && codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(a);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n}\nfunction getUnionName(codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function mergeAll(base, us) {\n    var equal = true;\n    var primitive = true;\n    var baseIsNotADictionary = !UnknownRecord.is(base);\n    for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {\n        var u = us_1[_i];\n        if (u !== base) {\n            equal = false;\n        }\n        if (UnknownRecord.is(u)) {\n            primitive = false;\n        }\n    }\n    if (equal) {\n        return base;\n    }\n    else if (primitive) {\n        return us[us.length - 1];\n    }\n    var r = {};\n    for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {\n        var u = us_2[_a];\n        for (var k in u) {\n            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {\n                r[k] = u[k];\n            }\n        }\n    }\n    return r;\n}\nfunction getProps(codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n}\nfunction stripKeys(o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n}\nfunction getExactTypeName(codec) {\n    if (isTypeC(codec)) {\n        return \"{| \".concat(getNameFromProps(codec.props), \" |}\");\n    }\n    else if (isPartialC(codec)) {\n        return getPartialTypeName(\"{| \".concat(getNameFromProps(codec.props), \" |}\"));\n    }\n    return \"Exact<\".concat(codec.name, \">\");\n}\nfunction isNonEmpty(as) {\n    return as.length > 0;\n}\n/**\n * @internal\n */\nexport var emptyTags = {};\nfunction intersect(a, b) {\n    var r = [];\n    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n        var v = a_1[_i];\n        if (b.indexOf(v) !== -1) {\n            r.push(v);\n        }\n    }\n    return r;\n}\nfunction mergeTags(a, b) {\n    if (a === emptyTags) {\n        return b;\n    }\n    if (b === emptyTags) {\n        return a;\n    }\n    var r = Object.assign({}, a);\n    for (var k in b) {\n        if (hasOwnProperty.call(a, k)) {\n            var intersection_1 = intersect(a[k], b[k]);\n            if (isNonEmpty(intersection_1)) {\n                r[k] = intersection_1;\n            }\n            else {\n                r = emptyTags;\n                break;\n            }\n        }\n        else {\n            r[k] = b[k];\n        }\n    }\n    return r;\n}\nfunction intersectTags(a, b) {\n    if (a === emptyTags || b === emptyTags) {\n        return emptyTags;\n    }\n    var r = emptyTags;\n    for (var k in a) {\n        if (hasOwnProperty.call(b, k)) {\n            var intersection_2 = intersect(a[k], b[k]);\n            if (intersection_2.length === 0) {\n                if (r === emptyTags) {\n                    r = {};\n                }\n                r[k] = a[k].concat(b[k]);\n            }\n        }\n    }\n    return r;\n}\n// tslint:disable-next-line: deprecation\nfunction isAnyC(codec) {\n    return codec._tag === 'AnyType';\n}\nfunction isLiteralC(codec) {\n    return codec._tag === 'LiteralType';\n}\nfunction isKeyofC(codec) {\n    return codec._tag === 'KeyofType';\n}\nfunction isTypeC(codec) {\n    return codec._tag === 'InterfaceType';\n}\nfunction isPartialC(codec) {\n    return codec._tag === 'PartialType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n    return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n    return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n    return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n    return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n    return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n    return codec._tag === 'RecursiveType';\n}\nvar lazyCodecs = [];\n/**\n * @internal\n */\nexport function getTags(codec) {\n    if (lazyCodecs.indexOf(codec) !== -1) {\n        return emptyTags;\n    }\n    if (isTypeC(codec) || isStrictC(codec)) {\n        var index = emptyTags;\n        // tslint:disable-next-line: forin\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralC(prop)) {\n                if (index === emptyTags) {\n                    index = {};\n                }\n                index[k] = [prop.value];\n            }\n        }\n        return index;\n    }\n    else if (isExactC(codec) || isRefinementC(codec)) {\n        return getTags(codec.type);\n    }\n    else if (isIntersectionC(codec)) {\n        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);\n    }\n    else if (isUnionC(codec)) {\n        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));\n    }\n    else if (isRecursiveC(codec)) {\n        lazyCodecs.push(codec);\n        var tags = getTags(codec.type);\n        lazyCodecs.pop();\n        return tags;\n    }\n    return emptyTags;\n}\n/**\n * @internal\n */\nexport function getIndex(codecs) {\n    var tags = getTags(codecs[0]);\n    var keys = Object.keys(tags);\n    var len = codecs.length;\n    var _loop_1 = function (k) {\n        var all = tags[k].slice();\n        var index = [tags[k]];\n        for (var i = 1; i < len; i++) {\n            var codec = codecs[i];\n            var ctags = getTags(codec);\n            var values = ctags[k];\n            // tslint:disable-next-line: strict-type-predicates\n            if (values === undefined) {\n                return \"continue-keys\";\n            }\n            else {\n                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {\n                    return \"continue-keys\";\n                }\n                else {\n                    all.push.apply(all, values);\n                    index.push(values);\n                }\n            }\n        }\n        return { value: [k, index] };\n    };\n    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var k = keys_1[_i];\n        var state_1 = _loop_1(k);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-keys\": continue keys;\n        }\n    }\n    return undefined;\n}\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\nexport { NullType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var nullType = new NullType();\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\nexport { UndefinedType };\nvar undefinedType = new UndefinedType();\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\nexport { VoidType };\n/**\n * @category primitives\n * @since 1.2.0\n */\nexport var voidType = new VoidType();\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\nexport { UnknownType };\n/**\n * @category primitives\n * @since 1.5.0\n */\nexport var unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\nexport { StringType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\nexport { NumberType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var number = new NumberType();\n/**\n * @since 2.1.0\n */\nvar BigIntType = /** @class */ (function (_super) {\n    __extends(BigIntType, _super);\n    function BigIntType() {\n        var _this = _super.call(this, 'bigint', \n        // tslint:disable-next-line: valid-typeof\n        function (u) { return typeof u === 'bigint'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BigIntType';\n        return _this;\n    }\n    return BigIntType;\n}(Type));\nexport { BigIntType };\n/**\n * @category primitives\n * @since 2.1.0\n */\nexport var bigint = new BigIntType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\nexport { BooleanType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\nexport { AnyArrayType };\n/**\n * @category primitives\n * @since 1.7.1\n */\nexport var UnknownArray = new AnyArrayType();\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object' && !Array.isArray(u); }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\nexport { AnyDictionaryType };\n/**\n * @category primitives\n * @since 1.7.1\n */\nexport var UnknownRecord = new AnyDictionaryType();\nexport { \n/**\n * @category primitives\n * @since 1.0.0\n */\nnullType as null, \n/**\n * @category primitives\n * @since 1.0.0\n */\nundefinedType as undefined, \n/**\n * @category primitives\n * @since 1.0.0\n */\nvoidType as void };\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\nexport { LiteralType };\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function literal(value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);\n}\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\nexport { KeyofType };\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function keyof(keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);\n}\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\nexport { RefinementType };\n/**\n * @category combinators\n * @since 1.8.1\n */\nexport function brand(codec, predicate, name) {\n    return refinement(codec, predicate, name);\n}\n/**\n * A branded codec representing an integer\n *\n * @category primitives\n * @since 1.8.1\n */\nexport var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    return RecursiveType;\n}(Type));\nexport { RecursiveType };\nObject.defineProperty(RecursiveType.prototype, 'type', {\n    get: function () {\n        return this.runDefinition();\n    },\n    enumerable: true,\n    configurable: true\n});\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function recursion(name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    return Self;\n}\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\nexport { ArrayType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function array(item, name) {\n    if (name === void 0) { name = \"Array<\".concat(item.name, \">\"); }\n    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(item.is); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var len = us.length;\n        var as = us;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var ui = us[i];\n            var result = item.validate(ui, appendContext(c, String(i), item, ui));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var ai = result.right;\n                if (ai !== ui) {\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = ai;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, item.encode === identity ? identity : function (a) { return a.map(item.encode); }, item);\n}\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\nexport { InterfaceType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function type(props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_1 = types[i];\n            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n}\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\nexport { PartialType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function partial(props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if (uk !== undefined && !props[k].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_2 = props[k];\n            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));\n            if (isLeft(result)) {\n                if (ak !== undefined) {\n                    pushAll(errors, result.left);\n                }\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n}\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\nexport { DictionaryType };\n/**\n * @category combinators\n * @since 1.7.1\n */\nexport function record(domain, codomain, name) {\n    var keys = getDomainKeys(domain);\n    return keys\n        ? enumerableRecord(Object.keys(keys), domain, codomain, name)\n        : nonEnumerableRecord(domain, codomain, name);\n}\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\nexport { UnionType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function union(codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var index = getIndex(codecs);\n    if (index !== undefined && codecs.length > 0) {\n        var tag_1 = index[0], groups_1 = index[1];\n        var len_1 = groups_1.length;\n        var find_1 = function (value) {\n            for (var i = 0; i < len_1; i++) {\n                if (groups_1[i].indexOf(value) !== -1) {\n                    return i;\n                }\n            }\n            return undefined;\n        };\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, function (u) {\n            if (UnknownRecord.is(u)) {\n                var i = find_1(u[tag_1]);\n                return i !== undefined ? codecs[i].is(u) : false;\n            }\n            return false;\n        }, function (u, c) {\n            var e = UnknownRecord.validate(u, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            var r = e.right;\n            var i = find_1(r[tag_1]);\n            if (i === undefined) {\n                return failure(u, c);\n            }\n            var codec = codecs[i];\n            return codec.validate(r, appendContext(c, String(i), codec, r));\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                var i = find_1(a[tag_1]);\n                if (i === undefined) {\n                    // https://github.com/gcanti/io-ts/pull/305\n                    throw new Error(\"no codec found to encode value in union codec \".concat(name));\n                }\n                else {\n                    return codecs[i].encode(a);\n                }\n            }, codecs, tag_1);\n    }\n    else {\n        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n            var errors = [];\n            for (var i = 0; i < codecs.length; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    return success(result.right);\n                }\n            }\n            return failures(errors);\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n                    var codec = codecs_1[_i];\n                    if (codec.is(a)) {\n                        return codec.encode(a);\n                    }\n                }\n                // https://github.com/gcanti/io-ts/pull/305\n                throw new Error(\"no codec found to encode value in union type \".concat(name));\n            }, codecs);\n    }\n}\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\nexport { IntersectionType };\nexport function intersection(codecs, name) {\n    if (name === void 0) { name = \"(\".concat(codecs.map(function (type) { return type.name; }).join(' & '), \")\"); }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    us.push(result.right);\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));\n        }, codecs.length === 0\n        ? identity\n        : function (a) {\n            return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); }));\n        }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\nexport { TupleType };\nexport function tuple(codecs, name) {\n    if (name === void 0) { name = \"[\".concat(codecs.map(function (type) { return type.name; }).join(', '), \"]\"); }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var a = us[i];\n            var type_3 = codecs[i];\n            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var va = result.right;\n                if (va !== a) {\n                    /* istanbul ignore next */\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = va;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, useIdentity(codecs) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\nexport { ReadonlyType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonly(codec, name) {\n    if (name === void 0) { name = \"Readonly<\".concat(codec.name, \">\"); }\n    return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\nexport { ReadonlyArrayType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonlyArray(item, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\".concat(item.name, \">\"); }\n    var codec = array(item);\n    return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);\n}\n/**\n * Strips additional properties, equivalent to `exact(type(props))`.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport var strict = function (props, name) { return exact(type(props), name); };\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\nexport { ExactType };\n/**\n * Strips additional properties.\n *\n * @category combinators\n * @since 1.1.0\n */\nexport function exact(codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var ce = codec.validate(u, c);\n        if (isLeft(ce)) {\n            return ce;\n        }\n        return right(stripKeys(ce.right, props));\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n}\n/**\n * @since 1.0.0\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\nexport { FunctionType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\nexport { NeverType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var never = new NeverType();\n/**\n * @since 1.0.0\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\nexport { AnyType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var any = new AnyType();\nexport function refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\".concat(codec.name, \" | \").concat(getFunctionName(predicate), \")\"); }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {\n        var e = codec.validate(i, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var a = e.right;\n        return predicate(a) ? success(a) : failure(a, c);\n    }, codec.encode, codec, predicate);\n}\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var Integer = refinement(number, Number.isInteger, 'Integer');\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\nexport { TaggedUnionType };\n/**\n * Use `union` instead.\n *\n * @category combinators\n * @since 1.3.0\n * @deprecated\n */\nexport var taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var U = union(codecs, name);\n    // tslint:disable-next-line: deprecation\n    if (U instanceof TaggedUnionType) {\n        return U;\n    }\n    else {\n        console.warn(\"[io-ts] Cannot build a tagged union for \".concat(name, \", returning a de-optimized union\"));\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n};\nexport { \n/**\n * Use `UnknownArray` instead.\n *\n * @category primitives\n * @deprecated\n * @since 1.0.0\n */\nUnknownArray as Array };\nexport { \n/**\n * Use `type` instead.\n *\n * @category combinators\n * @deprecated\n * @since 1.0.0\n */\ntype as interface };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * Use `UnknownRecord` instead.\n *\n * @category primitives\n * @since 1.0.0\n * @deprecated\n */\nexport var Dictionary = UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\nexport { ObjectType };\n/**\n * Use `UnknownRecord` instead.\n *\n * @category primitives\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var object = new ObjectType();\n/**\n * Use `record` instead.\n *\n * @category combinators\n * @since 1.0.0\n * @deprecated\n */\nexport var dictionary = record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\nexport { StrictType };\n/**\n * Drops the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */\nexport function clean(codec) {\n    return codec;\n}\nexport function alias(codec) {\n    return function () { return codec; };\n}\n"],
  "mappings": "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",
  "names": ["as", "left", "right", "left", "right", "flap", "left", "right", "left", "right", "isLeft", "_map", "map", "ap", "URI", "map", "isLeft", "right", "Functor", "URI", "_map", "as", "asUnit", "isLeft", "right", "ap", "URI", "_map", "isLeft", "right", "URI", "fromPredicate", "fromOption", "isLeft", "isLeft", "flap", "Functor", "apFirst", "apSecond", "tap", "fromOptionK", "chainOptionK", "liftNullable", "liftOption", "flatMapNullable", "flatMapOption", "filterOrElse", "bindTo", "Functor", "let_", "bind", "apS", "as", "isLeft", "right", "getApplySemigroup", "d", "b", "__spreadArray", "left", "right", "Type", "isLeft", "identity", "identity", "isLeft", "type", "__spreadArray", "isNonEmpty", "as", "tags", "codec", "k", "NullType", "UndefinedType", "identity", "VoidType", "identity", "UnknownType", "identity", "StringType", "identity", "NumberType", "identity", "BigIntType", "identity", "BooleanType", "identity", "AnyArrayType", "identity", "AnyDictionaryType", "identity", "LiteralType", "identity", "KeyofType", "identity", "RefinementType", "type", "RecursiveType", "ArrayType", "type", "isLeft", "as", "identity", "InterfaceType", "isLeft", "identity", "PartialType", "isLeft", "identity", "DictionaryType", "UnionType", "isLeft", "identity", "type", "IntersectionType", "type", "isLeft", "identity", "TupleType", "tuple", "type", "isLeft", "as", "identity", "ReadonlyType", "ReadonlyArrayType", "type", "ExactType", "type", "isLeft", "right", "FunctionType", "identity", "NeverType", "AnyType", "identity", "isLeft", "TaggedUnionType", "ObjectType", "identity", "StrictType"]
}
