## 開発の流れ
- [要件定義](./backend/README.md#サービス内容)
- [DB設計](./backend/README.md#データ構造)
- バックエンド技術選定
- [バックエンドのrouting決め](./backend/README.md#エンドポイント)
- [バックエンド詳細仕様決定](./backend/README.md#login)
- バックエンド実装
- フロントエンド技術選定
- [フロントエンドrouting決め](./frontend/README.md#route)
- フロントエンド実装
- solid-bootstrapからtailwindcssにリプレイス
- Docker対応

## 技術選定について
今回は、フロントエンドにSolidjs、バックエンドにNestJSを採用しました。
### フロントエンド
#### Solidjsを選定理由
以下の理由から、私はSolidJSを選択しました。最近は主にNext.jsを使っていましたが、新しいフロントエンドフレームワークを試してみたいと思いました。以前にVue.jsのバージョン2を使用したことがありますが、今回は別の選択肢を探しました。個人的にはReactの構文が好みなので、その構文に近いSolidJSを選びました。

### バックエンド
#### NestJSを選定理由
これまで、ほとんどAPIサーバーを作った経験がなく、PythonのFastAPIを使って成果物を作成したことがあります。前回FastAPIを使用した際、初めはかなりスムーズに進んだものの、型のない言語のために私のスキルではバグを減らすのが難しく、それほど複雑な処理も行っていなかったため、その後にNext.jsのAPIルートを使ってフルリプレースすることになりました。

この経験から、今度は型のある言語を使いたいと考えました。また、最近の職場でexpressに触れる機会が増えてきたため、expressのラッパーであるNestJSを選ぶことにしました。

#### SQLite選定理由

以前、Flask（Python）で成果物を作成する際にSQLiteを使用した経験があります。この経験から、業務で使用しているMongoDBと比較して、SQLiteはプロセス（デーモン）をあまり意識せずに使えるため、開発体験が非常に良かったです。さらに、SQLが使える点も魅力であり、そのためにSQLiteを選定しました。


## 感想、反省点、改善点
### 挑戦した点
#### 初めてのSolidjsとTailWindCSS
SolidJSの雰囲気は全体的にReactに近いと感じましたが、チュートリアルをやった感じでは、デフォルトで実装されているAPIがかなりウェブアプリケーションのフロント向きだなという印象です。

Reactと比べると、SolidJSのエコシステムの充実度合いに不安がありましたが、Reactではエコシステムで補われていた場所が、SolidJSではライブラリ本体に組み込まれたような感じで、APIを眺めていて楽しいライブラリでした。ただし、CSS周りを補完してくれるタイプのライブラリは少なく、index.htmlを直接書けるので、クラスを使うタイプのCDNで読み込めるCSSフレームワークは比較的簡単に使える一方で、便利なユーティリティ系コンポーネントを追加するライブラリはあまり見当たらなかったという印象があります（`react-bootstrap`のラッパーである`solid-bootstrap`くらいしか見つけられませんでした）。

最初は`react-bootstrap`を使ったことがあったので、その類似である`solid-bootstrap`を使用しましたが、index.htmlでBootstrapの読み込みが必要で、`npm`で一括で導入できなかったり、導入したつもりが一部のCSSが効いていなかったりと、少し使いづらい印象がありました。そのため、ある程度完成したところでTailwindCSSに置き換えることにしました。

ReactではTailwindCSSを使った`chakura-ui`などのCSSライブラリがありますが、Solidでは特に見当たらなかったため、最近呼んだAtomic Designを多少参考にしながら、自分でButtonコンポーネントやTextInputコンポーネントなどのユーティリティ系コンポーネントを初めて作ってみました。

Reactではユーティリティ系のコンポーネントを作る際に`{...props}`といった形で展開することができますが、SolidJSはライブラリの都合上、Propsを明示的に宣言する必要があり、ユーティリティ系のクラスを書く際の独自の概念に気づくことができました。

#### 初めてのNestJS
NestJSは徹底的にMVCパターンを意識したフレームワークであり、FlaskやExpressと比較すると、ディレクトリ構成が非常に厳格です。この厳格な構成に従ってコードを書く必要がありますが、それによってある程度整然としたコードが書けるため、最初は窮屈に感じました。しかしながら、プロジェクトがある程度完成するとバグが少なく、かつ読みやすいコードになっていたため、非常に満足しています。

実は、依存性注入（DI）については正確に理解していなかったのですが、NestJSを触る過程で何となくその雰囲気をつかむことができました。ただし、まだ十分な実感が得られなかったため、次回はDIに対してもっと意識的にアプローチしてみたいと考えています。

#### 初めてのDB

いままでバックエンドでDBを触ったことがないというコンプレックスがあったのですが、今回のおかげで解消できました。

DB設計も最初にやったため、そのあとにバックエンドを書き、最後にフロントエンドをかいたので、なかなか慣性系が見えず不安でしたが、改めて全体を考えるとなかなか順調に進んだと思います。

##### 初めてのTree構造

昔一度Todoistに触発されTree構造を持つTodoリストを作ろうとしたのですが、途中でツリー構造をどうやって保存すればいいかわからず、断念したことがありました。

そのあとに『SQLアンチパターン』を読み、ツリー構造を持つテーブルを作るときは、複数のやり方がすでにあるということを知り、今回は経路列挙法を使って実装しました。
今回採用したTypeormには、ツリー構造を扱うための機能があるのですが、今回はあえて自分で実装してみました。

#### 初めてのDocker対応

いままでDocker対応をしようと思っても、メイン機能の開発に時間を取られてしまい、なかなか手がつけられなかったのですが、今回は成果物自体がだいぶ単純な構造をしていたのと、職場で環境構築をする際にDockerが使われておらず、だいぶ苦労したのを思い出して、重い腰を上げてDocker対応をしました。 

実際Docker対応してみるとバックエンドとフロントエンドで共通して使っているファイルの扱いが少しやりづらく、私は完全に別のプロジェクトを二つ用意して、それぞれのDockerfileを作成しているのですが、職場では一回の `npm run dev` ですべてが実行できているので、そういったところをもう少し勉強したいと思いました。 

またほかにも、今回はDockerfileで逐一srcファイルをコンテナ内に持って行っているのですが、これだと開発時に毎回コンテナをビルドする必要があり、開発時にはさすがに良くないため、次からは開発時のみsrcファイルをマウントするようにしたいと思いました。

### 次回挑戦したいこと

今回はDBとTailwindCSSという個人的に社会人になる前に一度はそれを使った成果物を作りたいと思っていたものが使えたのでとても満足しています。

技術選定において一つ心残りなのが、スマートフォンアプリケーションにできなかったことです。 FlutterとPWAとReact-Nativeの三つで悩み今回は演習項目を3つがすべて最終課題がありなかなか時間がとれなかったので、あまり今の技術から離れすぎないPWAを使おうと思っていました。 ですが、あまりちゃんと調べず選んだ結果、自己証明書ではないhttps対応する必要があることを知らず、結局スマートフォン非対応になってしまいました。

次回こそ、スマートフォンアプリケーション開発に挑戦したいと思います。 